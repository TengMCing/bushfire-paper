---
title: "cluster_r"
author: "Weihao Li"
date: "2020年4月19日"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
Sys.setlocale("LC_ALL","English")
```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(furrr)
library(lubridate)
library(rnaturalearth)
library(igraph)
```

```{r 'define_read_hotspot'}
read_hotspot <- function(directory = "data/Himawari-8", from = '20190501', to = '20190701'){
  ### include from, exclude to
  
  fls = list.files(directory, full.names = TRUE)
  fls_short = list.files("data/Himawari-8", full.names = FALSE)
  fls_filter = (fls_short > paste('H08', from, sep = '_')) & (fls_short < paste('H08', to, sep = '_'))
  fls = fls[fls_filter]
  all = map(fls, read_csv, quote="'")
  d = bind_rows(all)
  return(d)
  
}
```

```{r message=FALSE, warning=FALSE}
hotspots = read_hotspot(from = "20191001", to ="20200331")
```

```{r}
# filter au
hotspots = hotspots %>%
  filter(between(lon, 112, 155)) %>% 
  filter(between(lat, -44, -10))

```

```{r}
au_map = ne_states(country = 'Australia', returnclass = 'sf') #get au map

hotspots = hotspots %>%
  filter(firepower > 100)
```

```{r}
hotspots = st_as_sf(x = hotspots, coords = c('lon','lat'))
st_crs(hotspots) = 4326
```

```{r}
tab = st_intersects(au_map$geometry, hotspots$geometry)
hotspots$state = ''
for (i in seq(1,nrow(au_map))){
  
  hotspots$state[tab[[i]]] = au_map$name[i]
  
}
```

```{r}
unidentified_point = hotspots[hotspots$state == '',]
tab2 = st_nearest_feature(unidentified_point$geometry, au_map$geometry)
hotspots$state[hotspots$state == ''] = au_map$name[tab2]
```

```{r}
hotspots$year = year(hotspots$`#obstime`)
hotspots$month = month(hotspots$`#obstime`)
hotspots$day = day(hotspots$`#obstime`)
hotspots$week = week(hotspots$`#obstime`)
hotspots$hour = hour(hotspots$`#obstime`)
```

```{r}
# filter VIC
hotspots_VIC = hotspots %>%
  filter(state == "Victoria")
rm(hotspots)
```

```{r}
# assign hour index for data
hotspots_VIC$hour_id = hotspots_VIC %>%
  group_indices(year,month,day,hour)

hotspots_VIC$obs_id = 1:nrow(hotspots_VIC)
temp_fire_id = c()
temp_obs_id = c()
```

```{r}
first_hour = filter(hotspots_VIC, hour_id == 1) %>%
  select(obs_id, year, month, day, hour_id, geometry)
```

```{r warning=FALSE}
# calculate dist matrix of first hour

dist_matrix = matrix(as.numeric(st_distance(first_hour$geometry, first_hour$geometry)),ncol =nrow(first_hour))

# if the distance between two points is less than 3 km, create an edge between them
neighbors = (dist_matrix<3000) 

# create graph by adjacency matrix
first_graph = graph.adjacency(neighbors, mode = 'undirected')

# compute clusters
cluster_result = clusters(first_graph)

# assign membership to each point
first_hour$fire_id = cluster_result$membership

# record centersfor each hour
group_centers = list()

calc_mean_r = function(X,Y,center_X,center_Y){
  temp_data = data.frame(X=X,Y=Y)
  temp_data = st_as_sf(temp_data, coords = c("X", "Y"), crs = 4326)
  points = temp_data$geometry
  centeroid = st_sfc(st_point(c(center_X,center_Y)))
  st_crs(centeroid) = 4326
  mean_r = mean(as.numeric(st_distance(points, centeroid)))
  return(mean_r)
}

# compute the centroid of each group
group_centers[[1]] = as.data.frame(st_coordinates(first_hour)) %>%
  mutate(fire_id = first_hour$fire_id) %>%
  group_by(fire_id) %>%
  summarise(lon = mean(X), lat = mean(Y), mean_r = calc_mean_r(X,Y,mean(X),mean(Y)))


group_centers[[1]] = st_as_sf(x = group_centers[[1]], coords = c("lon","lat"), crs = 4326)
group_centers[[1]]$active = 0

# assign the fire id back to the master data set
temp_fire_id = c(temp_fire_id, first_hour$fire_id)
temp_obs_id = c(temp_obs_id, first_hour$obs_id)
```


```{r}
max_hour = max(hotspots_VIC$hour_id)
for (i in seq(2,max_hour)){
  
  # copy the centers info from last hour
  group_centers[[i]] = group_centers[[i-1]]
  # let the active minus 1
  group_centers[[i]]$active = group_centers[[i]]$active - 1
  
  
  # get the current hour hotspots data
  current_hour = filter(hotspots_VIC, hour_id == i) %>%
  select(obs_id, geometry)
  
  # get the active fire center
  active_group = filter(group_centers[[i]], active > -24)
  
  # append the center geometry to the hotspots geometry vector
  if (nrow(active_group)>0){
    geom_info = c(current_hour$geometry, active_group$geometry)
  } else {
    geom_info = current_hour$geometry
  }
  
  
  # compute the dist matrix
  dist_matrix = matrix(as.numeric(st_distance(geom_info, geom_info)),ncol =nrow(current_hour)+nrow(active_group))
  
  # connect two points if they have less than 6000m distance or the mean_r of the active fires
  if (nrow(active_group)>0){

    temp_matrix = matrix(0L, nrow = dim(dist_matrix)[1], ncol = dim(dist_matrix)[2])
    partial_1 = matrix(rep(active_group$mean_r, dim(dist_matrix)[1]), nrow = dim(dist_matrix)[2], byrow = TRUE)
    partial_2 = matrix(rep(active_group$mean_r, dim(dist_matrix)[2]), ncol = dim(dist_matrix)[2], byrow = FALSE)
    temp_matrix[(nrow(current_hour)+1):dim(dist_matrix)[1],] = partial_2
    temp_matrix[,(nrow(current_hour)+1):dim(dist_matrix)[2]] = partial_1

    neighbors = ((dist_matrix<3000) + (dist_matrix<temp_matrix))>0

  } else {
    neighbors = (dist_matrix<3000)
  }
  
  # use the adjancency to create a graph
  current_graph = graph.adjacency(neighbors, mode = 'undirected')
  
  # find the components in the graph
  cluster_result = clusters(current_graph)
  
  # get the membership for the hotspots
  current_fire_id = cluster_result$membership[1:nrow(current_hour)]
  
  current_hour$fire_id = NA
  
  # get the membership for the active centers
  if (nrow(active_group)>0){
    previous_center_current_id = cluster_result$membership[(nrow(current_hour)+1):length(cluster_result$membership)]
    
    # if the hotspots share the same group as active centers, assign those hotspots a previous fire_id
    current_hour$fire_id =  active_group$fire_id[match(current_fire_id, previous_center_current_id)]
  }
  
  # hotspots that doesn't in the same group as active centers will have a missing value, we need to assign them new fire id
  
  # we first get the membership of those points
  temp_membership = current_fire_id[is.na(current_hour$fire_id)]
  
  # we need to slightly adjust the membership to make it start from 1 and common difference equal to 1
  temp_membership = data.frame(temp_membership = temp_membership) %>%
    group_indices(temp_membership)
  # and add the total number of fire we known
  temp_membership = temp_membership + nrow(group_centers[[i]])

    
  # assign them back to those missing entries
  current_hour$fire_id[is.na(current_hour$fire_id)] = temp_membership

  
  # now all the current hour points has a fire id, we can recompute the centers and mean_r
  current_centers = as.data.frame(st_coordinates(current_hour)) %>%
  mutate(fire_id = current_hour$fire_id) %>%
  group_by(fire_id) %>%
  summarise(lon = mean(X), lat = mean(Y), mean_r = calc_mean_r(X,Y,mean(X),mean(Y)))
  
  
  current_centers$active = 0
  current_centers = st_as_sf(x = current_centers, coords = c("lon","lat"), crs = 4326)
  
  # replace the center info
  group_centers[[i]] = group_centers[[i]] %>%
    filter(!(fire_id %in% current_centers$fire_id))
  group_centers[[i]] = rbind(group_centers[[i]], current_centers)
  group_centers[[i]] = arrange(group_centers[[i]], fire_id)
  
  # assign the fire id back to master data set
  temp_fire_id = c(temp_fire_id, current_hour$fire_id)
  temp_obs_id = c(temp_obs_id, current_hour$obs_id)
    
}

```

```{r}
myfun = function(x,y){
  temp = as.data.frame(st_coordinates(x)) %>%
    mutate(hour_id = y) %>%
    mutate(mean_r = x$mean_r)
  temp = temp %>%
    mutate(fire_id = 1:nrow(temp))
  temp
}

center_move = imap(group_centers, ~myfun(.x,.y)) %>%
  reduce(rbind)
```


```{r}
hotspots_VIC$fire_id_3km_mean = temp_fire_id
output_3km_mean = as.data.frame(hotspots_VIC) %>%
  select(`#obstime`, firepower, state, year, month, day, week, hour, hour_id, obs_id, fire_id_3km_mean)
temp = as.data.frame(st_coordinates(hotspots_VIC))
output_3km_mean$lon = temp$X
output_3km_mean$lat = temp$Y

write.csv(output_3km_mean, 'data/hotspots_3km_mean.csv', row.names = FALSE)
write.csv(center_move， 'data/fire_3km_mean.csv', row.names = FALSE)
rm(output_3km_mean)
```


```{r}
max(center_move$fire_id)
```

```{r}
summary(center_move$mean_r)

```



```{r}
center_move %>%
  group_by(fire_id) %>%
  summarise(variance = var(X) + var(Y)) %>%
  arrange(desc(variance)) %>%
  head(10)

```

```{r}
library(ggrepel)
library(ggforce)
library(viridis)

fire_id_list = center_move %>%
  group_by(fire_id) %>%
  summarise(variance = var(X) + var(Y)) %>%
  arrange(desc(variance)) %>%
  head(10)

fire_id_list = fire_id_list$fire_id

for (fire_id_used in fire_id_list){

test = filter(center_move, fire_id == fire_id_used)
test = test %>%
  mutate(same = lag(X) == X & lag(Y) == Y) %>%
  filter(same != TRUE| is.na(same))

test = test %>%
  mutate(id = 1:nrow(test))

hotspots_data_id = st_jitter(filter(mutate(hotspots_VIC, fire_id = temp_fire_id), fire_id == fire_id_used), amount = 0.01)

p = ggplot(test)  +
  geom_sf(data = hotspots_data_id, aes(col = hour_id), alpha = 0.5) +
  geom_path(aes(x=X,y=Y), size = 1) +
  annotate('point', x=test$X[1],y=test$Y[1], col = 'green', size = 2)+ 
  scale_colour_distiller(palette  = 'RdYlBu') +
  theme_bw() +
  ggtitle(cat(fire_id_used))
print(p)
}

```

```{r}
test2 = center_move %>%
  arrange(fire_id, hour_id) %>%
  group_by(fire_id) %>%
  summarise(x = first(X), y = first(Y), hour_id = first(hour_id))

ggplot(test2)+
  geom_point(aes(x=x,y=y, col=hour_id))+ 
  scale_colour_distiller(palette  = 'RdYlBu')
```

```{r}
# read all roads in australia
au_road = st_read("australia-latest-free.shp/gis_osm_roads_free_1.shp")
```


```{r}
# extract the geometry information
geo_road = st_geometry(au_road)
geo_state = st_geometry(au_map)

# assign each road to its corresponding state, one road can be assigned to mutiple states
roads_in_states = st_intersects(geo_state, geo_road)
dim(roads_in_states)
```

```{r}
# we want all the roads which have an intersection with VIC
VIC_roads_index = roads_in_states[[7]]
```

```{r}
# transfrom the dataset into dataframe so that we can use indexing
au_road_df = as.data.frame(au_road)

# get the roads in VIC
VIC_road = au_road_df[VIC_roads_index,]
rm(au_road)
```

```{r}
test2 = st_as_sf(test2, coords = c('x','y'), crs = 4326)
nearest_roads = st_nearest_feature(test2$geometry, VIC_road$geometry)

dist_vector = st_distance(test2$geometry, VIC_road$geometry[nearest_roads], by_element = TRUE)
dist_vector = as.numeric(dist_vector)
```

```{r}
summary(dist_vector)
```


```{r 'read_recreation_site_data'}
recreation = st_read("SDM698290\\ll_gda94\\sde_shape\\whole\\VIC\\FORESTS\\layer\\recweb_site.shp")

```

```{r 'show_recreation_map'}
test2 = center_move %>%
  arrange(fire_id, hour_id) %>%
  group_by(fire_id) %>%
  summarise(x = first(X), y = first(Y), hour_id = first(hour_id))

ggplot(recreation) +
  geom_sf(data = au_map, fill = "grey", colour = "black")+
  coord_sf(ylim = c(-40,-34), xlim = c(140,150)) +
  geom_point(aes(x = LONGITUDE, y = LATITUDE), fill ='red', color = 'white', pch=21, alpha = 0.5, size = 3)+
  geom_point(data = test2, aes(x=x,y=y))+ 
  scale_colour_distiller(palette  = 'RdYlBu')+
  theme_bw() +
  ggtitle('VIC recreation site')
  
```



